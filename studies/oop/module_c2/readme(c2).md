# В этом модуле мы с вами всё ещё продолжим изучать ООП. 
Окончательно погрузимся в его тонкости, станем самыми настоящими мастерами объектно-ориентированного подхода и начнём работать с исключениями!

Если говорить в контексте Python, то мы узнаем, как реализовать общие для любого объекта методы, посмотрим, как можно удобно воплощать концепции ООП с помощью встроенных декораторов класса, и начнём разбирать исключительные ситуации, приближаясь к написанию «непобедимых» программ. 

## C2.2. Cтатические методы

Статические методы — это методы, которые относятся сразу ко всем объектам класса и могут вызываться вне конкретного объекта, обращаясь к классу напрямую.

Например, нам надо вывести какую-то информацию или выполнить действие, которое не зависит от какого-либо объекта. Допустим, это действие для всех объектов абсолютно одинаково и не зависит от значения полей. В этом случае мы можем использовать статические методы.

Смотрим пример кода:
```
class StaticClass:

    @staticmethod  # помечаем метод, который мы хотим сделать статичным декоратором @staticmethod
    def bar():
        print("bar")

StaticClass.bar()
```
И тут вы спросите: «Чё за дела? Как же так, а где self? Почему мы вызываем метод без объекта?». На что найдётся довольно простой ответ. Дело в том, что статические методы не принимают первым аргументом наш любимый self. Если вы помните тему из ООП (модуль С1), то там во всех методах обязательно стоял self первым аргументом для получения состояния объекта. В этом же случае основной принцип статических методов — их выполнение не зависит от состояния конкретного объекта. С одной стороны, мы можем быстро и удобно вызывать какие-то общие методы, но с другой — получить информацию о состоянии объекта не получится, даже если мы будем вызывать статический метод через объект, а не через прямое обращение к классу, а так делать тоже можно.

Пример вызова статического метода через объект:
```
class StaticClass:

    @staticmethod
    def bar():
        print("bar")

f = StaticClass()
f.bar()  # вызывать статические методы через объекты так же никто не запрещает
```

Вызов статического метода через объекты не возбраняется, но считается не очень хорошим тоном. И да, прошу заметить, что вызовы статических методов у любого объекта будут совпадать и не зависеть друг от друга, как и было сказано ранее.

В каких случаях стоит использовать статические методы?

Хороший вопрос. Статические методы надо использовать, когда мы должны выполнить какое-то действие, которое не зависит от состояния объекта. Например, прочитать какой-нибудь файл или вывести на экран какую-либо информацию. Иногда через статические методы удобно хранить константы.
```
class StaticClass:

    @staticmethod
    def GET_BAR():  # вспоминаем, что константа пишется со всеми заглавными буквами (в простонародье — капсом)
        return "bar"

print(StaticClass.GET_BAR())
```
В результате увидим в консоли: bar.

Хотя тут можно было бы обойтись и полями. Да и по правде признаться, для хранения констант лучше всего, конечно же, использовать поля, чтобы не смущать своих коллег. Используйте статические методы в основном для работы с внешними ресурсами (API, файлы и т. д.).

## C2.3. Декораторы класса: @property, @classmethod. Ещё пару слов о нашей бывшей возлюбленной — инкапсуляции

В данном юните мы рассмотрим встроенные средства языка Python для реализации вычисляемых свойств, ещё немножко поговорим про ООП в контексте инкапсуляции, научимся грамотно прописывать геттеры и сеттеры.

Итак, будем идти по порядку.

Для начала небольшое напоминание тем, кто подзабыл, что такое инкапсуляция.

Инкапсуляция — это одна из основ объектно-ориентированного программирования, которая говорит нам о том, что поля (переменные) класса и его методы (функции класса) надо объединять в одну целую систему.
Затрагивая тему инкапсуляции, почти во всех учебниках толком ничего не говорится о прекрасном встроенном декораторе @property.

Напоминаю, что декораторы — это определённые штуки в языке Python, которые позволяют менять поведение функции (или, как вы сейчас убедитесь, и метода), не меняя её исходного кода. В прошлом юните мы с помощью декоратора писали статические методы, вспоминаем.

@property очень классный декоратор, он-то, по сути, и обеспечивает нам прямой путь к инкапсуляции, позволяя объединить методы и поля. Давайте же скорее взглянем на пример кода с использованием этого декоратора.
```
# создадим класс собаки
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    # создадим свойство human_age, которое будет переводить возраст животного в человеческий
    @property  # тот самый магический декоратор
    def human_age(self):
        return self.age * 7.3


jane = Dog("jane", 4)
# т.к. метод помечен декоратором property, то нам не надо вызывать этот метод, чтобы получить результат
print(jane.human_age)
```
В этом куске кода мы пометили декоратором @property метод human_age. В итоге мы смогли получить результат работы метода, не вызывая его явно (без декоратора нам бы пришлось дописать в конец его вызов). Как правило, на этом объяснение этого потрясающего декоратора и заканчивается, а очень даже зря. Ведь помимо неявного вызова метода, мы можем похожим образом устанавливать значение в поле. Давайте же дополним наш код ещё одним свойством — шкалой счастья.

Для этого поля мы создадим геттер и сеттер. Из темы инкапсуляция (модуль C1) вы должны помнить, что:

геттеры — это специальные методы для получения значения поля класса;
сеттеры — это специальные методы для установки значений в поле класса.
```
class Dog:
    _happiness = 10

    def __init__(self, name, age):
        self.name = name
        self.age = age

    @property
    def human_age(self):
        return self.age * 7.3

    # добавим новое поле — шкала счастья
    @property
    def happiness(self):
        return self._happiness

    # с помощью декоратора setter мы можем неявно передать во второй 
    # аргумент значение, находящееся справа от равно, а не закидывать это 
    # значение в скобки, как мы это делали в модуле C1, когда не знали о 
    # декораторах класса 
    @happiness.setter
    # допустим, мы хотим, чтобы счастье питомца измерялось шкалой от 0 до 100
    def happiness(self, value):
        if value <= 100 and value >= 0:
            self._happiness = value
        else:
            raise ValueError("Happiness must be between 0 ... 100")


jane = Dog("jane", 4)
jane.happiness = 100  # осчастливим нашу собаку < :
print(jane.happiness)
```
В этом случае программа выведет нам на экран поле happiness, т. е. 100.

Вдобавок к комментариям в коде важно отметить, что декораторы .setter должны называться так же, как и метод, помеченный декоратором @property, для которого вы хотите устанавливать значение, иначе интерпретатор выдаст ошибку.

Благодаря декоратору @.setter можно использовать инкапсуляцию, сохраняя привычное нам обращение к полю через точку, а установку нового значения через =. Вот такой вот магический декоратор @property.

Ну и напоследок стоит сказать пару слов о декораторе @classmethod, который встречается довольно редко, ввиду его малой понятности для обывателей и синтаксической громоздкости.

Используется он, как правило, чтобы открыть путь в полиморфизм (вспоминаем модуль C1, но если кратко — полиморфизм это разное поведение методов класса-родителя в классах-наследниках).
