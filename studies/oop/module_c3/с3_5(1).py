# Контекстный менеджер — определенная структура в языке Python (класс или генератор),
# основывающаяся на главном принципе: при его открытии и закрытии срабатывает заранее написанный программистом код.

# Открытие происходит при входе в блок с помощью ключевого слова with. Закрытие происходит, когда блок заканчивается.
# Например, на входе — открывается файл, на выходе — закрывается.
# Ну и самый простой пример использования контекстного менеджера с использованием ключевого слова with с файлами:
#
# with open("file.bin", "wt") as f: # открываем файл с помощью with
#     f.write("abcdefg")

# Чтобы написать контекстный менеджер нужно всего лишь помнить о нескольких вещах:
#
# Нужно создать класс и написать в нём метод __enter__. Код в этом методе будет выполняться при входе в контекстный менеджер (при создании объекта с ключевым словом with).
# Написать метод __exit__. Этот метод будет выполнять код, помещённый в него, на выходе.
# Добавить в этот метод три дополнительных аргумента помимо self — exc_type, exc_val, exc_tb. Зачем они нужны, расскажу чуть позже.

from datetime import datetime
import time  # проверять действие измерителя будем с помощью библиотеки time


class Timer:
    def __init__(self):
        pass

    def __enter__(self):  # этот метод вызывается при запуске с помощью with. Если вы хотите вернуть какой-то объект,
# чтобы потом работать с ним в контекстном менеджере, как в примере с файлом, то просто верните этот объект через return
        self.start = datetime.utcnow()
        return None

    def __exit__(self, exc_type, exc_val, exc_tb): # этот метод срабатывает при выходе из контекстного менеджера
        print(f'Time passed: {(datetime.utcnow() - self.start).total_seconds()}')

with Timer():
    time.sleep(2) # засыпаем на 2 секунды
# В консоль должно вывестись примерно следующее:  Time passed: 2.00099

# О каждом из них по порядку:
#
# exc_type — это тип исключения, из-за которого вылетел контекстный менеджер.
# Если всё прошло успешно, то значение этого аргумента будет None.
# exc_val — сообщение в исключении. Аналогично: если всё прошло успешно, этот аргумент будет None.
# exc_tb — объект сообщения от интерпретатора. Лучше его вообще не трогать, если вы не разработчик языка, но, тем
# не менее, он всегда ждёт вас здесь. Возможно, когда-то, после нашего курса вы…

# на генераторе
from datetime import datetime
import time

from contextlib import contextmanager  # импортируем нужный нам декоратор


@contextmanager  # оборачиваем функцию в декоратор contextmanager
def timer():
    start = datetime.utcnow()
    yield  # если вам нужно что-то вернуть через контекстный менеджер, просто вставьте этот объект сюда.
    print(f"Time passed: {(datetime.utcnow() - start).total_seconds()}")


with timer():
    time.sleep(2)
# Результат работы такого контекстного менеджера на основе генераторов абсолютно такой же:
# Time passed: 2.001097

print('')
print('Задание 3.5.6')
class OpenFile:
    def __init__(self, path, type):
        self.file = open(path, type)

    def __enter__(self):
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.file.close()

with OpenFile('proba.txt', 'wt') as f:
    f.write('Мой 1-й контексный менеджер ....')
#p.s. надо как-то указывать кодировку читаемого файла
