#  B5.4. Функции

print('Задание 5.4.9')
# Напишите рекурсивную функцию, находящую минимальный элемент списка без использования циклов и
# встроенной функции min().

def min_list(L):
    if len(L) == 1:
        return L[0]
    return L[0] if L[0] < min_list(L[1:]) else min_list(L[1:])

print(min_list([12,4,10,7]))

print('Задание 5.4.10')
# Напишите рекурсивную функцию, которая зеркально разворачивает число. Предполагается, что число не содержит нули.

def mirror(a, res=0):
    return mirror(a//10, res*10 + a % 10) if a else res
print('mirror', mirror(123))
print(1//10) # 0

print('Задание 5.4.11')
# Поработаем над более сложной рекурсивной функцией.
# Сейчас попробуем реализовать функцию equal(N, S), проверяющую, совпадает ли сумма цифр числа N с числом S.
# При написании программы следует обратить внимание на то, что, если S стала отрицательной, то необходимо сразу вернуть False.

N = 124
def summ(N):
    lst = [int(i) for i in str(N)]  # преобразование числа в список цифр
    return sum(lst)

print('sum: ', summ(N))

def equal(N,S):
    if S < 0:
        return False
    if N < 10:
        return N == S
    else:
        equal(N//10, S - N % 10)

# Генераторы и итераторы
# Теперь попробуем написать генератор для приближённого вычисления числа e = 2.718.

# e_n = (1 + 1/n)**n  # Для вычисления числа e с определённой точностью можно использовать формулу:

print('Задание 5.4.13. Реализуйте функцию-генератор, каждое значение которого — приближение числа e с некоторым числом n.')

def e():
    n =1
    while True:
        yield (1 + 1/n) ** n
        n += 1

iter_obj = iter("Hello!")
print(next(iter_obj))
print(next(iter_obj))
print(next(iter_obj))
print(next(iter_obj))
print(next(iter_obj))
print(next(iter_obj))
# print(next(iter_obj))  #  ошибка

# Декораторы
# Пусть у нас есть функция, которая должна извлекать из базы данных какую-то информацию.
# На начальном этапе разработки мы не заботились о том, что это можно делать только при условии,
# что пользователь программы авторизовался, но сейчас время пришло. Попробуем написать декоратор,
# который позволяет вызвать функцию, только если она вызывается авторизованным пользователем.

# yesno = input("""Введите Y, если хотите авторизоваться, или N,
#              если хотите продолжить работу как анонимный пользователь: """)
#
# auth = yesno == "Y"
#
def is_auth(func):
    def wrapper():
        if auth:
            print("Пользователь авторизован")
            func()
        else:
            print("Пользователь не авторизован. Функция выполнена не будет")
    return wrapper
#
# @is_auth
# def from_db():
#     print("some data from database")

#from_db()

# ===================   Задание 5.4.15  ====================================

print('Задание 5.4.15 Реализуйте функцию-декоратор, которая проверяет доступ к функции по username пользователя. '
      'Все username пользователей хранятся в глобальной области видимости в списке USERS. При согласии пользователя '
      'на авторизацию ему предлагается ввести username, который также хранится в глобальной области видимости. '
      'Функция должна использовать два декоратора: один для проверки авторизации вообще (реализован выше), '
      'второй — для проверки доступа.')

USERS = ['admin', 'guest', 'director', 'root', 'superstar']

yesno = input("""Введите Y, если хотите авторизоваться, или N, 
             если хотите продолжить работу как анонимный пользователь: """)

auth = yesno == "Y"

if auth:
    username = input("Введите ваш username:")


def has_access(func):
    def wrapper():
        if username in USERS:
             print("Авторизован как", username)
             func()
        else:
            print("Доступ пользователю", username, "запрещён")
    return wrapper

@is_auth
@has_access
def from_db():
    print("some data from database")

from_db()