#  D3.13. Выполнение запроса. EXPLAIN

### Как уже говорилось ранее, любая программа на языке SQL называется запросом. 
Термины «запрос» и «программа» для SQL можно считать синонимами. 
Запрос, к примеру, может создавать структуру сложной БД и наполнять её данными. 
Такой запрос может быть размером в сотни тысяч строк. 
Другой запрос может быть в одну строку и просто запрашивать все данные из одной таблицы.

### Вроде такого:

SELECT * FROM vendors;
Ещё один пример запроса: 
для PostgreSQL часто используют утилиту pg_dump для создания резервных копий БД. 
Эта утилита создаёт резервную копию БД в формате SQL-запроса, который потом можно выполнить и восстановить БД. 
Запросы выполняет СУБД.

Чтобы СУБД выполнила запрос, мы должны, очевидно, сообщить ей об этом. 
Для этого СУБД предоставляют программный интерфейс (API), который используют и штатные инструменты (PGAdmin или psql) 
и сторонние приложения (например, наше приложение на Python). Выполнение запроса на стороне СУБД — процесс многоэтапный. 
Алгоритм выполнения запроса немного различается между разными СУБД, но общий смысл примерно одинаковый.

### Для PostgreSQL этапы выполнения запроса выглядят так:

1. Подготовка. Синтаксический анализ запроса, оптимизация кода запроса, переписывание запроса в оптимизированной форме, 
генерация итогового кода запроса.
2. Выполнение (интерпретация). Выполнение операторов с параметрами, переданными в запросе.
3. Результат. Формирование набора данных, полученных в результате выполнения запроса, и передача их клиентскому приложению.

Для чего я описал эти этапы выполнения? Нужно ли разработчику знать эти внутренние механизмы СУБД? Нужно!

Дело в том, что один и тот же запрос может быть выполнен совершенно по-разному в зависимости от различных факторов. 
На этапе подготовки происходит анализ, оптимизация и переписывание запроса. 
В результате анализа СУБД строит так называемый «план выполнения запроса».

### План — это представление в виде графа последовательности операций и оценки затрат на операции, 
### которые требуются для выполнения запроса.

При составлении плана СУБД использует информацию о состоянии БД. 
К такой информации относится количество строк в таблицах, наличие индексов и многое другое. 
СУБД использует сложные алгоритмы, эвристики и правила для составления оптимального плана выполнения запроса. 
Этот план и оценку времени выполнения запроса можно увидеть с помощью оператора EXPLAIN, который добавляется 
в начало анализируемого запроса. Подробнее можно почитать [здесь](https://postgrespro.ru/docs/postgresql/13/using-explain).

Давайте посмотрим простой пример плана выполнения запроса. 
Для этого я написал процедуру, которая создала 1000 записей в таблице posts, и выполнил следующий запрос:
```
EXPLAIN SELECT * FROM posts WHERE author <> 'Author 10' AND  id > 0 AND id < 500 ORDER BY id;
```
Ответ: Получает все статьи, где автором не является Author 10 и номера статей в диапазоне от 1 до 499.

В результате получен следующий план выполнения:
```
Index Scan using posts_pkey on posts  (cost=0.28..30.46 rows=497 width=21)
  Index Cond: ((id > 0) AND (id < 500))
  Filter: (author <> 'Author 10'::text)
```  
Выглядит сложно и непонятно, однако можно увидеть, что план предполагает использование индекса первичного ключа 
таблицы для выборки, после чего данные будут отфильтрованы по идентификатору и автору.

Вы могли заметить, что план выполнения запроса содержит характеристику cost. 
Эта характеристика означает затраты на выполнение каждого из этапов плана выполнения. 
Именно уменьшение этого параметра и лежит в основе оптимизации и повышения производительности запросов. 
Однако стоит помнить, что:
* cost является оценкой, а не точным значением.
Значения для cost приведены в условных единицах (а не в секундах или миллисекундах).
Типовым приёмом оптимизации запросов является анализ плана выполнения и последующая оптимизация структуры БД. 
* Чаще всего для повышения производительности создают индексы или уменьшают количество объединений таблиц в запросе.