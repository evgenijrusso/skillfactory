# D4.2. Параметры запросов

В предыдущем модуле упоминалось, что выполнение запроса происходит в несколько этапов. 
Сначала выполняется разбор, переписывание и оптимизация запроса. 
Потом происходит его интерпретация (выполнение). После этого результат возвращается клиенту, инициировавшему запрос.

## Давайте посмотрим на эти этапы повнимательнее.
1. Разбор запроса заключается в синтаксическом анализе, проверке корректности, соответствия запроса схеме БД и т.д.
2. Переписывание и оптимизация заключаются в переписывании запроса в целях достижения минимальных вычислительных затрат 
для его выполнения. На этом этапе включаются сложные алгоритмы СУБД. 
На выходе из этого этапа получается план выполнения запроса.
3. Интерпретация (выполнение) запроса заключается в вычислении или получении из БД результата выполнения плана запроса, 
сформированного на предыдущем этапе.
4. Возврат результата источнику запроса.

Первые два этапа (синтаксический разбор, переписывание и оптимизация запроса) называются подготовкой запроса.

Вероятно, вы догадываетесь, что этот этап очень непростой с алгоритмической точки зрения. 
Например, при построении плана запроса учитываются такие параметры, как количество строк в таблицах, 
наличие индексов, диапазон проверяемых значений и многое другое.

Сам план запроса может выглядеть, например, так: QUERY PLAN
------------------------------------------------------------------------------------------
 Hash Join  (cost=230.47..713.98 rows=101 width=488)
   Hash Cond: (t2.unique2 = t1.unique2)
   ->  Seq Scan on tenk2 t2  (cost=0.00..445.00 rows=10000 width=244)
   ->  Hash  (cost=229.20..229.20 rows=101 width=244)
         ->  Bitmap Heap Scan on tenk1 t1  (cost=5.07..229.20 rows=101 width=244)
               Recheck Cond: (unique1 < 100)
               ->  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0)
                     Index Cond: (unique1 < 100)
 
Для нас не так важно, из каких именно этапов состоит план, — важно, что он довольно-таки непрост, и, вероятно, 
для его составления были затрачены серьёзные ресурсы.

При этом БД предназначена для выполнения запросов, источником которых является наше серверное приложение (бэкенд). 
Для серверного приложения источником запросов обычно является приложение пользователя (фронтенд) или другая часть 
нашей информационной системы (особенно если мы используем микросервисный подход к проектированию). Для приложения 
пользователя, в свою очередь, источником запроса является пользователь. Существуют различные топологии, но обычно 
схема примерно такая.

Давайте представим себе типовые запросы пользователя приложения, которые будут по цепочке ретранслированы в БД. 
Для нашего учебного приложения, хранящего в базе каталог товаров, такими типовыми запросами будут:

- получение списка товаров определённой категории,
- получение подробной информации о конкретном товаре,
- получение информации о поставщике,
- получение всех товаров некоторого производителя.
И так далее.

При этом, как вы понимаете, в нашем серверном приложении для каждого такого типового запроса будут разработаны методы, 
которые будут отправлять запрос в БД и возвращать полученные данные приложению пользователя. 
Такие методы будут принимать на вход аргументы, по которым будут осуществляться поиск и фильтрация. 
Например, для получения товаров некоторого производителя, метод в качестве аргумента будет принимать идентификатор производителя.

Соответствующий код на Python с использованием psycopg2 может выглядеть примерно так:

# products_by_manufacturer возвращает все товары определённого производителя.
def products_by_manufacturer(id: int) -> List[Tuple(int, str, str)]:

Примечание. В данном модуле мы немного забежим вперёд и посмотрим примеры кода на Go, выполняющего запросы к БД. 
Разработку приложений баз данных мы будем изучать в следующем модуле.

Сам SQL-запрос будет выглядеть как-то так:
- SELECT name, price FROM products WHERE manufacturer_id = id

- Вероятно, что вы уже понимаете, что идентификатор производителя из примера Python-кода выше нужно как-то подставить 
в SQL-запрос. Для этого существует два основных способа.

## 1. Способ 1. Конкатенация строк
Мы должны перевести идентификатор в строку и объединить с остальными частями запроса. Выглядеть это будет примерно так:

query = f"SELECT name, price FROM products WHERE manufacturer_id = {id}"
В конце запроса на место id мы подставляем преобразованный в строку идентификатор производителя.

Такой способ работает, но обладает рядом существенных недостатков.
1. Если в запросе много переменных, конструкция будет сложной и плохо читаемой.
2. Такой способ не защищает от атаки типа SQL Injection.
Смысл атаки в том, что злоумышленник может передать вместо текстового параметра произвольный SQL-код. 
Например, при определённых условиях может получиться так, что, если пользователь вместо имени введёт в форме что-нибудь вроде:
- DROP TABLE users;
То СУБД может исполнить этот код и удалить соответствующую таблицу. 
Чтобы такого не случалось, мы должны чётко указать СУБД, что в определённом месте у нас аргумент запроса, 
а не произвольный код. Для этого есть способ №2.

## Способ 2. Параметры запроса
Все РСУБД поддерживают так называемые параметры запроса. 
То есть в определённых местах SQL-кода мы можем указать СУБД, что здесь впоследствии будет значение. 
У каждой СУБД свой синтаксис, для PostgreSQL запрос товаров с параметром будет выглядеть так:

- SELECT name, price FROM products WHERE manufacturer_id = $1
Параметры в PostgreSQL обозначаются как $n, где n — порядковый номер параметра.

Например, запрос с тремя параметрами может быть таким:
```
SELECT email, first_name, age
FROM users
WHERE first_name = $1 AND age > $2 AND age < $3
```

Если мы к этому запросу передадим три значения, например, "Александр", 20 и 50, то такой запрос вернёт всех пользователей 
с именем Александр в возрасте от 21 до 49. Каждое переданное значение будет подставлено на место параметра. 
Первое значение — на место параметра $1, второе — на место $2 и так далее.

В случае запроса с параметром СУБД знает, что на месте параметра должно быть какое-то 
значение: строка, число, время или что-то ещё. Поэтому значение параметра не может быть интерпретировано как SQL-код. 
Если передать вместо значения какой-нибудь SQL-оператор, то будет ошибка.

Теперь давайте вернёмся к началу главы, когда мы рассуждали про этап подготовки запроса. 
Если мы часто запрашиваем из БД все товары по производителю, то получается, что мы часто выполняем один и тот же запрос, 
в котором меняются лишь значения параметров. Такая же ситуация будет и для других типовых запросов в нашем приложении. 
В этом случае было бы логичным, если бы СУБД для каждого типа запроса вычислила план выполнения один раз и впоследствии 
переиспользовала его, подставляя в запрос только новые значения параметров.

Именно так в действительности и происходит. Запрос с параметрами можно предварительно подготовить, 
после чего СУБД составит план выполнения, сохранит запрос в БД и отправит приложению номер такого сохранённого запроса. 
После этого приложение может быстро выполнять этот сохранённый запрос, передавая в него параметры.

### Такие сохранённые после этапа подготовки запросы называются подготовленными запросами.

Подготовленные запросы особенно хороши в случаях, когда требуется многократно выполнить один и тот же запрос с 
разными значениями параметров. Например, мы хотим вставить в БД 100000 новых записей о товарах. Запросы будут 
идентичны, отличаться будут только значения параметров. 
Или же нам требуется получить информацию по каждому товару, идентификаторы которых переданы массивом.

Во всех таких случаях происходит выполнение одинаковых SQL-запросов в цикле. Такие операции ещё называют пакетными (batch).

Если использовать подготовленные запросы, то вычисление плана выполнения будет выполнено однократно, 
что значительно сократит общее время выполнения.

Для иллюстрации приведём полный код функции на Python, использующей параметры в запросе.

```
def products_by_manufacturer(id: int) -> List[Tuple[Any, Any, Any]]:
    conn = psycopg.connect('database address here')
    with conn.cursor() as cur:
        cur.execute(
            f'SELECT name, price
            FROM  products
            WHERE manufacturer_id = { id }
            ORDER BY id',
        )
    return cur.fetchall()
```
