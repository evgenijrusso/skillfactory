# D4.8. Триггеры

Триггер — это ещё один объект БД, который предназначен для выполнения некоторых действий при изменении БД.

Триггер представляет собой хранимую процедуру, которая автоматически запускается в СУБД при возникновении какого-либо события. 
Обычно триггеры срабатывают при вставке, изменении или удалении записей в некоторой таблице. 
Однако PostgreSQL позволяет подключать триггеры и к изменению схемы БД. 
Последняя возможность почти не применяется на практике и нам не интересна.

Вы можете спросить: «А для чего обычно применяются триггеры?» Вообще говоря, они применяются нечасто. 
Обычно они нужны для проверок корректности данных в случаях, когда такую проверку нельзя организовать с помощью 
стандартного ограничения CHECK. Давайте рассмотрим такой пример.

Допустим, у нашего каталога товаров есть требование, что любой добавляемый товар должен быть не дороже, 
чем двукратная стоимость самого дорогого товара в каталоге. Создать такое ограничение с помощью CHECK не получится, 
поскольку ограничения не поддерживают сложные запросы и вызов функций. Значит, нам остаётся создать триггер, который 
будет вызываться при вставке или обновлении записей в таблице товаров. Этот триггер будет сравнивать цену товара при 
каждой вставке или изменении с ценой самого дорогого товара.

Запрос будет выглядеть так:
```
Запрос будет выглядеть так:

-- процедура-триггер для проверки цены товара
CREATE OR REPLACE FUNCTION check_price()
  RETURNS TRIGGER AS $$
BEGIN
	-- проверка цены новой или обновляемой записи
	IF NEW.price < (SELECT max(price) FROM products)::INTEGER * 2
		-- если ОК, то триггер возвращает новую запись без изменений
        THEN RETURN NEW;
		-- если не ОК, то вызывается ошибка
        ELSE RAISE EXCEPTION 'Invalid price'; --RETURN NULL;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- регистрация триггера для таблицы товаров
CREATE TRIGGER check_price_trigger BEFORE INSERT OR UPDATE ON products
FOR EACH ROW EXECUTE PROCEDURE check_price();
```
Теперь, если попытаться вставить какой-нибудь экстремально дорогой товар, то СУБД выдаст ошибку и операция будет отменена.

- INSERT INTO products(name, price) VALUES('iPhone', 1000000000);
Как видите, СУБД вернула ошибку, которую мы определили в хранимой процедуре.