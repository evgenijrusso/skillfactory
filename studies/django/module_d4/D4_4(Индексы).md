# D4.4. Индексы

Индекс — важнейший объект БД. Индексы позволяют ускорить поиск данных в таблицах по значению некоторых атрибутов.

Давайте разберём поподробнее, как работают индексы и в каких случаях они дают прирост в производительности.

Допустим, у нас часто выполняется запрос:

SELECT name, price FROM products WHERE price BETWEEN 100 AND 1000;

Именно это и помогают сделать индексы. Индекс является дополнительной структурой данных, привязанной к таблице. 
Он хранит избыточную для таблицы информацию, связывающую значение одного или группы атрибутов с информацией о расположении данной записи.

Важно! Индекс всегда определён для одного или нескольких атрибутов одной таблицы.

Давайте посмотрим на бинарное дерево поиска.

Бинарное дерево — основная структура данных, используемая для хранения индекса.

Если построить бинарное дерево для атрибута price, то каждый узел такого дерева будет содержать в качестве своего 
значения цену товара и указатель на расположение записи. Поэтому, когда мы захотим выбрать все товары с ценой от 
100 до 1000, СУБД сможет пройти по дереву до узла с ценой 100, далее дойти до узла с ценой больше 1000, после 
чего получить все записи, на которые указывают узлы между этими крайними узлами.

- Какая сложность в терминах О-нотации у полного сканирования таблицы? - линейная
- Какая сложность в терминах О-нотации у поиска по бинарному дереву? - Логарифмическая

Использование бинарного дерева значительно сокращает время поиска записей. 
При этом ускорение будет тем заметнее, чем больше записей в таблице.

Важно! Если в таблице мало записей (несколько десятков или сотен), то СУБД, скорее всего, вообще не будет 
использовать индекс — невыгодно.

Давайте добавим индекс для атрибута цена таблицы товаров, использующий бинарное дерево в качестве структуры хранения значений.

- CREATE INDEX products_price_idx ON products USING btree (price);

Запрос выше создаёт индекс с именем products_price_idx для атрибута price таблицы products, используя алгоритм 
индексирования btree (бинарное дерево). Бинарное дерево — алгоритм по умолчанию, и его можно было не указывать. 
В результате выполнения этого запроса для таблицы products для всех записей будет построено бинарное дерево поиска. 
Теперь любой запрос диапазона цен будет использовать индекс и выполняться значительно быстрее, особенно если у нас много записей в таблице.


Примечание. Бинарные деревья работают только для таких типов данных атрибутов, для которых определены 
операции сравнения: в основном, это числа и строки.

Отлично, но давайте подумаем: а что, если мы чаще всего ищем товар с конкретной ценой, а не диапазоном? 
В этом случае вместо полного обхода таблицы (O(n)) СУБД выполнит поиск по дереву (O(log n)), что значительно быстрее. 
Но всё же это не так быстро, как если бы мы использовали другую популярную структуру данных — хеш-таблицу. 
В этом случае поиск был бы ещё быстрее!

Какая сложность в О-нотации у поиска по хеш-таблице? - постоянная

Именно потому, что разные структуры данных и алгоритмы поиска имеют различную эффективность в зависимости от типа запроса, 
современные СУБД поддерживают несколько алгоритмов индексирования. Для поиска конкретных значений лучшие результаты даст 
хеш-таблица, поэтому давайте добавим такой индекс в нашу БД.

- CREATE INDEX products_price_hash_idx ON products USING hash (price);
### Схематично такой индекс может выглядеть так:

Ключ: 'Альфа', Значения (идентификаторы записей): {2, 4, 35};
Ключ: 'Банк', Значения (идентификаторы записей): {30, 51};
Ключ: 'Волга', Значения (идентификаторы записей): {2, 30};
...
и т.д.
Как вы, наверное, догадались, такой индекс является аналогом алфавитного указателя в книгах и используется для 
полнотекстового поиска. Для каждого слова в поисковом запросе мы можем практически мгновенно получить список 
всех записей (документов), где это слово встречалось.

Теперь давайте поговорим о минусах индексов. 
Да, как вы должны знать, «there is no silver bullet», то есть за любое ускорение чем-то приходится платить.

В случае с индексами за ускорение операций поиска и выборки данных приходится платить замедлением операций 
обновления (UPDATE) и вставки (INSERT) данных.

Действительно, при каждом изменении данных СУБД должна будет обновить индексы, привязанные к изменяемой таблице. 
Поэтому если ваше приложение чаще меняет данные, чем осуществляет по ним поиск, то создание индексов может замедлить работу приложения.

Кроме того, если у вас уже есть таблица с огромным количеством записей, то создание индекса может занять много 
времени и даже заблокировать всю таблицу на время выполнения операции (зависит от СУБД).

 Примечание. Postgres до версии 11 блокирует таблицу при создании индекса. В таблице на 2 миллиарда записей создание 
 индекса у нас занимало несколько часов на загруженном сервере.
 
Поэтому при создании индексов важно понимать характер работы пользователей с индексируемыми данными. 
Также желательно проверять эффективность индексов на тестовых данных. Подробности — в скринкасте выше.