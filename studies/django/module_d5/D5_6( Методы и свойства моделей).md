## D5.6. Методы и свойства моделей

Мы хорошо поработали в предыдущем юните, рассмотрев возможные поля в моделях, и как их можно настраивать. 
Более того, мы создали сами модели для нашего примера с интернет-магазином. Теперь мы можем научиться что-то 
делать с данными, которые будут храниться в этих моделях. Поэтому мы рассмотрим:

* методы моделей,
* свойства моделей,
* встроенные в Django модели (User).
* 
Когда мы обсуждали объектно-ориентированное программирование, научились помимо переменных в объектах создавать 
ещё и методы, которые могут с ними работать. Давайте посмотрим на этот же механизм в классах-моделях.

Найдите способы учиться активно — в дополнение к обычному изучению модулей. 
Поищите в интернете другие варианты объяснений. Читайте дополнительную литературу и делитесь полезными ссылками 
с однокурсниками, это поможет вам создавать собственную базу знаний. Поддерживайте общение и обсуждайте не 
только сложности, появившиеся в обучении, но и делитесь инсайтами, которые вас посетили.

Методы моделей
--------------
Создание методов моделей по сути ничем не отличается от методов классов в общем виде. 
Внутри класса мы должны определить функцию, первым аргументом которой всегда является экземпляр этого класса. 
В случае моделей мы должны понимать, что этот экземпляр есть не что иное, как объект сущности или, что то же 
самое, строка в таблице базы данных.

В общем виде эту функцию мы записываем следующим образом:
```
class SomeModel(models.Model):
    field_int = models.IntegerField()
    field_text = models.TextField()

    def some_method(self):
        // делаем что-то с данными
        return value  # можем вернуть что-то, но не обязательно
```

Попробуем создать несколько методов для формируемой нами базы данных. 
Например, в модели ProductOrder создать метод, который будет возвращать стоимость товаров (product) в 
зависимости от их количества (amount).
```
class ProductOrder(models.Model):
    product = models.ForeignKey(Product, on_delete = models.CASCADE)
    order = models.ForeignKey(Order, on_delete = models.CASCADE)
    amount = models.IntegerField(default = 1) 
   
    def product_sum(self):
        product_price = self.product.price
        return product_price * self.amount   
```

Этот метод сначала получает цену за продукт. 
Сам объект продукта содержится в переменной self в виде поля product. 
Оно, в свою очередь, само является объектом модели Product, которая содержит поле price. 
Создавая такую цепочку self → product → price, мы получаем нужное нам значение. 
После этого мы умножаем его на self.amount — поле «количество» из текущего объекта. 
Их произведение и даёт нам нужную сумму.

Или же мы можем получить только фамилию сотрудника из поля full_name в модели Staff.

* Задание 5.6.1
Напишите метод get_last_name() модели Staff, который возвращает только фамилию из поля full_name. 
Предполагается, что ФИО записано в формате «Иванов Иван Иванович». 
Вспомните функции строк, позволяющие это сделать.
```
def get_last_name(self):
    return self.full_name.split()[0]   # Иванов (только фамилию из поля full_name)
```

В модели Order мы можем получить время, которое прошло с момента заказа товара до его получения покупателем. 
Для этого нужно сначала написать метод, который при завершении заказа, устанавливал бы текущее время в поле 
time_out.

```
from datetime import datetime

def finish_order(self):
    self.time_out = datetime.now()
    self.complete = True
    self.save()
```
В первой строке этого листинга кода мы импортировали модуль datetime, 
который позволяет получить текущее время. В самом методе в поле time_out мы записали его с помощью 
функции now(), установили флаг «Завершён» в логическую переменную, а после чего сохранили объект, 
передав это значение в базу данных. К методу save() мы ещё вернёмся в конце этого модуля, а сейчас продолжим.

Для выполнения следующего задания нужно знать несколько вещей про объекты времени. 
Поля time_in и time_out хранятся в виде объектов datetime в Python-представлении. 
Эти объекты можно вычитать, и результатом такого действия будет объект timedelta из того же пакета datetime. 
Он обладает методом total_seconds(), который возвращает целое число — количество секунд между двумя временными 
точками.

Пусть у нас есть два объекта типа datetime — before и after.
`seconds = (after — before).total_seconds()`

В эту переменную запишется искомое количество секунд.

__Задание 5.6.2__
Напишите метод get_duration() модели Order, возвращающий время выполнения заказа в минутах 
(округлить до целого). Если заказ ещё не выполнен, то вернуть количество минут с начала выполнения заказа.

Ответ:
```
def get_duration(self):
    if self.complete:  # если завершён, возвращаем разность объектов
        return (self.time_out - self.time_in).total_seconds() // 60
    else:  # если ещё нет, то сколько длится выполнение
        return (datetime.now(timezone.utc) - self.time_in).total_seconds() // 60
```

Свойства моделей
---------------
В разделе про ООП мы также рассматривали интересный способ объявления полей классов — через свойства. 
Их также можно использовать в Django, но с большой аккуратностью. 
Давайте напишем свойства getter и setter для поля amount модели ProductOrder. 
Мы хотим возвращать это же значение. Однако при записи мы будем проверять, 
не стало ли amount отрицательным числом. И если стало, записывать ноль.
```
class ProductOrder(models.Model):
    product = models.ForeignKey(Product, on_delete = models.CASCADE)
    order = models.ForeignKey(Order, on_delete = models.CASCADE)
    _amount = models.IntegerField(default = 1, db_column = 'amount') 

    @property
    def amount(self):
        return self._amount

    @amount.setter
    def amount(self, value):
        self._amount = int(value) if value >= 0 else 0
        self.save()
```
В первую очередь мы изменили название поля на _amount (добавили нижнее подчёркивание). 
Это необходимо, чтобы создание свойства не переписало объект IntegerField, который хранится в amount. 
Однако, чтобы не возникло конфликтов в базе данных, и не пришлось делать миграцию, мы оставили название 
колонки в базе данных тем же самым — amount, задав его явно.

После чего мы объявили свойство с помощью декоратора property. 
В первом свойстве (getter) мы просто возвращаем значение поля, а в setter проверяем, является ли 
неотрицательным значение, которое мы хотим записать. Если да, то берём от него целую часть и 
записываем в поле, а если нет, то записываем ноль.

Однако стоит отметить, что использовать свойства в моделях может быть опасно. 
Для написания геттеров и сеттеров полей модели лучше всего делать перегрузку некоторых функций, 
а для проверки значений на соответствие можно добавлять валидаторы к полям. И с тем, и с другим 
способом мы познакомимся в дальнейшем. Однако вполне приемлемым является написание свойств для 
полей, несвязанных с базой данных. Принципы их работы аналогичны тем, что рассматривались в теме ООП.

Встроенная модель User
----------------------
Фреймворк Django, помимо прочих своих удобств, которые обсуждались и будут обсуждаться, 
имеет некоторое количество моделей «из коробки» — уже реализованных и готовых к боевой работе моделей, 
которые часто используются. Даже в тех примерах, которые мы рассматривали ранее (корпоративная система 
и интернет-магазин, например), всегда предполагалось наличие Личного кабинета, т. е. наличие авторизованных 
пользователей и хранение информации о них. Действительно, большинство сайтов, которыми мы активно пользуемся, 
имеют систему авторизации, а значит где-то в недрах веб-приложения хранятся некие данные пользователей.

Одно из предложений Django — это встроенная модель пользователей User.
Её можно найти в пакете django.contrib.auth в скрипте models.py. 
В этом скрипте можно найти встроенную модель User. 
Он является конкретным классом-потомком от абстрактного класса AbstractUser. 
Он в свою очередь наследуется от AbstractBaseUser. Рассмотрим обе эти модели.

Итак, давайте обратимся к его исходному коду:
```
class AbstractBaseUser(models.Model):
    password = models.CharField(_('password'), max_length=128)
    last_login = models.DateTimeField(_('last login'), blank=True, null=True)

    is_active = True

class AbstractUser(AbstractBaseUser, PermissionsMixin):
    """
    An abstract base class implementing a fully featured User model with
    admin-compliant permissions.

    Username and password are required. Other fields are optional.
    """
    username_validator = UnicodeUsernameValidator()

    username = models.CharField(
        _('username'),
        max_length=150,
        unique=True,
        help_text=_('Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.'),
        validators=[username_validator],
        error_messages={
            'unique': _("A user with that username already exists."),
        },
    )
    first_name = models.CharField(_('first name'), max_length=150, blank=True)
    last_name = models.CharField(_('last name'), max_length=150, blank=True)
    email = models.EmailField(_('email address'), blank=True)
    is_staff = models.BooleanField(
        _('staff status'),
        default=False,
        help_text=_('Designates whether the user can log into this admin site.'),
    )
    is_active = models.BooleanField(
        _('active'),
        default=True,
        help_text=_(
            'Designates whether this user should be treated as active. '
            'Unselect this instead of deleting accounts.'
        ),
    )
    date_joined = models.DateTimeField(_('date joined'), default=timezone.now)
```

Сначала может показаться слишком сложным, но давайте пройдёмся по строчкам и поймём, что не так все страшно.

Итак, в модели AbstractBaseUser определяются поля:

1. `password` как CharField с ограничением по длине 128 символов. Однако, это не означает, что можно записать пароль такой длины. Дело в том, что в базе данных пароль не хранится в «чистом» виде, а кодируется специальным образом.
2. `last_login` как DateTimeField. Дата и время последней активности в веб-приложении
 
В модели `AbstractUser` есть поля:

1. `username` как CharField. Его длина должна не превосходить 150 символов и, более того, 
оно должно быть уникальным (unique = True).
2. `first_name` и `last_name` — поля, хранящие имя и фамилию пользователя соответственно.
3. `email` — поле типа EmailField. Электронная почта пользователя.
4. `is_staff` — булево поле, определяющее, может ли пользователь заходить на панель администратора.
5. `is_active` — ещё одно булево поле, определяющее доступ пользователя на сайт в целом.
6. `date_joined` — дата и время регистрации пользователя.

В документации Django, а также в скриптах, которые мы рассматривали сейчас, можно найти множество примеров 
свойств и методов моделей.