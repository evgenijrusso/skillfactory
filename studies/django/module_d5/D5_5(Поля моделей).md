## D5.5. Поля моделей

В этом юните мы рассмотрим процесс создания моделей и их полей. 
Вспомним из первых юнитов этого модуля, что каждая сущность обладает некими атрибутами. 
Они имеют определённый тип и некоторые ограничения, которые можно на них поставить (длина последовательности символов
или NOT NULL, например).

В том же модуле, где хранится класс Model, от которого мы наследуем все модели, можно найти ещё несколько классов, 
позволяющих определить поля модели. Эти поля DjangoORM самостоятельно трансформирует в атрибуты сущностей уже в 
базе данных. Давайте сначала посмотрим, какие типы полей предлагает Django, а после этого научимся их применять.

###  Типы полей в моделях 
* __AutoField__

Целочисленное поле, которое автоматически увеличивается для каждой строки. 
Это аналог уникального идентификатора, который мы вводили вручную с помощью SQL, указывая свойство AUTOINCREMENT. 
Как правило, это поле не нужно добавлять вручную. Django самостоятельно добавляет его в каждую модель, 
устанавливая его как первичный ключ. Однако стоит понимать, что оно есть, даже если мы его не добавили вручную.

`object_id = models.AutoField()`

* __BooleanField__
Поле логических переменных — True или False.

`boolean = models.BooleanField(default = False)`

Обладает параметром default — значение по умолчанию.

* __CharField__
Строковый тип. Используется, как правило, для небольших строковых данных.

`small_string = models.CharField(max_length = 64,default = "Default value")`

Параметры:
max_length — максимальная длина строки, которую можно записать в поле.
default — значение по умолчанию.

* __DateField__
Поле, предназначенное для хранения даты. В Python оно представлено объектом datetime.date.

some_data = models.DateField(auto_now_add = True)
Имеет несколько исключающих друг друга параметров (может использоваться только один):

1. auto_now
Если True, то автоматически устанавливает в это поле текущую дату каждый раз при сохранении объекта.
2. auto_now_add
Если True, то автоматически устанавливает в это поле дату создания объекта.
3. default  Значение по умолчанию.

* __DateTimeField__
 
Класс, представляющий дату и время. В Python представлен объектом datetime.datetime.

`some_datetime = models.DateTimeField(auto_now_add)`

Имеет аналогичные взаимоисключающие параметры auto_now, auto_now_add, default.

* __EmailField__
 
Подтип поля CharField, специализированный на хранении электронной почты. 
Отличие заключается в том, что при сохранении объекта, данные проверяются на соответствие формату 
anyone@anywhere.com.

`personal_email = models.EmailField()`

* __FileField, FilePathField__

Поля, позволяющие хранить файлы и/или пути к файлам.

* __FloatField__
 
Поле для чисел с плавающей точкой.

`price = models.FloatField(default = 0.99)`
Также может иметь значение по умолчанию.

* __ImageField__
 
Поле, где хранится путь к изображению, которое необходимо связать с данным объектом модели. 
Например, в случае профиля пользователя нужно хранить его аватарку. 
Более подробно это поле будет рассмотрено в одном из следующих модулей.

* __IntegerField__
Целочисленное поле. Может принимать значения от -2147483648 до 2147483647.

`count = models.IntegerField(default = 0)`

* __TextField__

Поле, оптимизированное для хранения больших текстов.

`article_text = models.TextField()`

* `TimeField`

Поле, аналогичное DateField и DateTimeField. 
В этом случае позволяет хранить только время как Python-объект datetime.time.

`tea_time = models.TimeField()`

* __URLField__

Поле, реализующее CharField, но конкретно для хранения адресов интернет-страниц (URL).

`link = models.URLField()`

Естественно, что это не все типы полей, которые можно использовать в моделях. 
Более того, все поля обладают ещё другими специфичными (но необязательными, как правило) аргументами. 
Для более подробного ознакомления предлагаем обратиться к документации.

Давайте попробуем реализовать несколько таблиц из уже знакомого нам примера с интернет-магазином. 
Сущности Order и ProductOrder обладают связями, поэтому их мы отложим на некоторое время, а 
сейчас сконцентрируемся на создании моделей Product и Staff.

Связи между моделями
-------------------
В предыдущем юните мы достаточно подробно разбирали возможные связи между сущностями — «один к одному», 
«один ко многим» и «многие ко многим». Эти связи в точности именно так реализуются и в DjangoORM.

Чтобы определить любую связь между моделями, мы должны в одном из классов создать поле соответствующего типа:

one_to_one_relation = models.OneToOneField(some_model)
one_to_many_relation = models.ForeignKey(some_model)
many_to_many_relation = models.ManyToManyField(some_model)

В данном коде some_model — это модель, к которой строится связь. 
Её можно передать как сам класс модели, так и название класса в виде строки. 
Снова обратимся к нашему примеру и восстановим связь «один ко многим» между сущностями Staff и Order. 
Заодно спроектируем последнюю.

А теперь попробуем перенести это в DjangoORM:
```
class Order(models.Model):
    time_in = models.DateTimeField(auto_now_add = True)
    time_out = models.DateTimeField(null = True)
    cost = models.FloatField(default = 0.0)
    pickup = models.BooleanField(default = False)    complete = models.BooleanField(default = False)
    staff = models.ForeignKey(Staff, on_delete = models.CASCADE)
```

Итак, давайте вновь внимательно посмотрим на написанный код. 
Мы создали класс Order, унаследовав его от базовой модели models.Model. И определили в нём несколько полей:

__time_in__

Поле, содержащее дату и время оформления заказа. 
Мы указали параметр auto_now_add равным True, чтобы это значение автоматически устанавливалось на текущую дату и 
время при поступлении заказа в базу данных. 
Это происходит именно в момент оформления заказа.

__time_out__ 

Поле, которое содержит дату и время выдачи заказа. 
Здесь не может быть какого-то автоматически предустановленного времени, поэтому никакие из рассмотренных 
специфичных аргументов мы не указали. Однако добавили аргумент null = True, который указывает DjangoORM и, 
тем самым базе данных, что здесь может быть пустая ячейка. Почему так? При создании объекта (оформлении заказа)
мы ещё не знаем время выдачи — это поле будет обновляться позже.

__cost__ 

Число с плавающей точкой — общая стоимость заказа.

__pickup__

Логическая переменная, которая равна True, если заказ нужно собрать для самовывоза и False, если на доставку. 
По умолчанию выбран второй вариант.

__complete__

Логическая переменная, которая равна True, если заказ уже выполнен. 
Мы добавили это поле только на этом этапе, но оно будет полезно в следующей теме.

__staff__ 
Здесь мы использовали специальный тип поля для связи «один ко многим», а именно её и реализует связь между 
«Сотрудником» и «Заказом». В первом аргументе мы указали класс, к которому строится связь. Однако могли 
бы записать и через строковое имя.
`staff — models.ForeignKey('Staff', on_delete=models.CASCADE)`

Стоит отдельно остановиться на параметре on_delete, который мы ещё не обсуждали подробно.

Допустим, у одного из сотрудников было выполнено N каких-то заказов за всё время его работы. 
В какой-то момент он решил уволиться, а мы, в свою очередь, решили удалить его из базы данных активных 
сотрудников (модель Staff). Что в таком случае делать базе данных? Ведь получается, что мы из модели 
заказов будем ссылаться на несуществующего сотрудника. Могут возникнуть конфликты. И чтобы их разрешить, 
разработчику базы данных предлагается один из вариантов решения такой ситуации — установить это поле, 
равное None, записать какое-то дефолтное значение или же произвести каскадное удаление. 
Его суть заключается в том, что все связанные объекты также удалятся вместе с исходным. 
Если мы, например, удаляем сотрудника из модели Staff, то также и удалятся все заказы, 
которые он когда-либо выполнял. О других возможных способах можно почитать здесь.

Связи «один к одному» в нашем примере пока что нет, но суть её применения аналогична. 
А вот на связи «многие ко многим» остановимся подробнее. Такая связь в нашем примере реализуется между 
моделями Order и Product, используя промежуточную таблицу ProductOrder. Давайте напишем её.
.... (см. проект NewsPaper)

Отлично, мы создали промежуточную таблицу для связи «многие ко многим», но этого мало. 
Чтобы во всю силу использовать мощь этой связи, мы должны явно указать, что между моделями 
Order и Product существует эта связь и указать промежуточную модель.

Для этого определим в модели Order дополнительное поле products, которое будет реализовывать эту связь:
```
class Order(models.Model):
    time_in = models.DateTimeField(auto_now_add = True)
    time_out = models.DateTimeField(null = True)
    cost = models.FloatField(default = 0.0)
    pickup = models.BooleanField(default = False)    complete = models.BooleanField(default = False)
    staff = models.ForeignKey(Staff, on_delete = models.CASCADE)
    
    products = models.ManyToManyField(Product, through = 'ProductOrder')
```
Мы здесь имеем новое поле модели products, реализующее связь с моделью Product через промежуточную таблицу ProductOrder.

Давайте попробуем собрать это в единый скрипт:
```
from django.db import models

class Staff(models.Model):
    full_name = models.CharField(max_length = 255)
    position = models.CharField(max_length = 255)
    labor_contract = models.IntegerField()

class Product(models.Model):
    name = models.CharField(max_length = 255)
    price = models.FloatField(default = 0.0)
    composition = models.TextField(default = "Состав не указан")

class Order(models.Model):
    time_in = models.DateTimeField(auto_now_add = True)
    time_out = models.DateTimeField(null = True)
    cost = models.FloatField(default = 0.0)
    pickup = models.BooleanField(default = False)    complete = models.BooleanField(default = False)
    staff = models.ForeignKey(Staff, on_delete = models.CASCADE)
    
    products = models.ManyToManyField(Product, through = 'ProductOrder')

class ProductOrder(models.Model):
    product = models.ForeignKey(Product, on_delete = models.CASCADE)
    order = models.ForeignKey(Order, on_delete = models.CASCADE)
    amount = models.IntegerField(default = 1) 
```

Остаётся вопрос — куда деть этот код, чтобы он заработал?

Допустим мы имеем проект Mac, в нём мы можем создать приложение rest 
(по тем же алгоритмам, которые мы рассматривали до этого). В нём мы обнаружим файл models.py. 
И именно в нём и должен содержаться этот код.

Однако мы только написали код на Python. 
Дальше мы должны указать Django перевести это на язык, понятный базе данных. 
Это выполняется с помощью миграций. Подробнее о миграциях, об их создании и редактировании мы остановимся 
в следующих юнитах, а сейчас выполним две команды: одна для создания миграций, другая — для их применения.
```
(venv) ~/django-projects/Mac $ python3 manage.py makemigrations
(venv) ~/django-projects/Mac $ python3 manage.py migrate
```

